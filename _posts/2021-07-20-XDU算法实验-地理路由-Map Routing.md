---
title: 地理路由-MapRouting（XDU算法实验）
author: Travis <Hongxu Wei>
date: 2021-07-20 18:32:00 +0800
categories: [Algorithm, Coding]
tags: [Java, Course, 算法实验]
math: true
---



## 一、问题描述

实现经典的Dijkstra最短路径算法，并对其进行优化。 这种算法广泛应用于地理信息系统（GIS），包括MapQuest和基于GPS的汽车导航系统。

**地图**。 本次实验对象是图**maps**或**graphs**，其中顶点为平面上的点，这些点由权值为欧氏距离的边相连成图。 可将顶点视为城市，将边视为相连的道路。 为了在文件中表示地图，我们列出了顶点数和边数，然后列出顶点（索引后跟其**x**和**y**坐标），然后列出边（顶点对），最后列出源点和汇点。 例如，如下左图信息表示右图：

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210718181605.png" style="zoom:67%;" />

**Dijkstra算法**。 Dijkstra算法是最短路径问题的经典解决方案。 它在教科书第21章中有描述。 基本思路不难理解。 对于图中的每个顶点，我们维护从源点到该顶点的最短已知的路径长度，并且将这些长度保持在优先队列（**priority queue**, **PQ**）中。 初始时，我们把所有的顶点放在这个队列中，并设置高优先级，然后将源点的优先级设为0.0。 算法通过从**PQ**中取出最低优先级的顶点，然后检查可从该顶点经由一条边可达的所有顶点，以查看这条边是否提供了从源点到那个顶点较之之前已知的最短路径的更短路径。 如果是这样，它会降低优先级来反映这种新的信息。

这里给出了Dijkstra算法计算从0到5的最短路径0-1-2-5的详细过程。

process 0 (0.0)

​      lower 3 to 3841.9

​      lower 1 to 1897.4

process 1 (1897.4)

​      lower 4 to 3776.2

​      lower 2 to 2537.7

process 2 (2537.7)

​      lower 5 to 6274.0

process 4 (3776.2)

process 3 (3841.9)

process 5 (6274.0)

该方法计算最短路径的长度。 为了记录路径，我们还保持每个顶点的源点到该顶点最短路径上的前驱。 文件Euclidean Graph.java，Point.java，IndexPQ.java，IntIterator.java和Dijkstra.java提供了针对map的Dijkstra算法的基本框架实现，你应该以此作为起点。 客户端程序ShortestPath.java求解一个单源点最短路径问题，并使用图形绘制了结果。 客户端程序Paths.java求解了许多最短路径问题，并将最短路径打印到标准输出。 客户端程序Distances.java求解了许多最短路径问题，仅将距离打印到标准输出。

**目标**。 优化Dijkstra算法，使其可以处理给定图的数千条最短路径查询。 一旦你读取图（并可选地预处理），你的程序应该在亚线性时间内解决最短路径问题。 一种方法是预先计算出所有顶点对的最短路径；然而，你无法承受存储所有这些信息所需的二次空间。 你的目标是减少每次最短路径计算所涉及的工作量，而不会占用过多的空间。 建议你选择下面的一些潜在想法来实现， 或者你可以开发和实现自己的想法。

**想法1**. Dijkstra算法的朴素实现检查图中的所有**V**个顶点。 减少检查的顶点数量的一种策略是一旦发现目的地的最短路径就停止搜索。 通过这种方法，可以使每个最短路径查询的运行时间与**E**' log **V**'成比例，其中**E**'和**V**'是Dijkstra算法检查的边和顶点数。 然而，这需要一些小心，因为只是重新初始化所有距离为∞就需要与**V**成正比的时间。由于你在不断执行查询，因而只需重新初始化在先前查询中改变的那些值来大大加速查询。

**想法2**. 你可以利用问题的欧式几何来进一步减少搜索时间，这在算法书的第21.5节描述过。对于一般图，Dijkstra通过将d[w]更新为d[v] + 从v到w的距离来松弛边v-w。 对于地图，则将d[w]更新为d[v] + 从v到w的距离 + 从w到d的欧式距离 - 从v到d的欧式距离。 这种方法称之为A*算法。这种启发式方法会有性能上的影响，但不会影响正确性。

**想法3**. 使用更快的优先队列。 在提供的优先队列中有一些优化空间。 你也可以考虑使用Sedgewick程序20.10中的多路堆。

**测试**。 美国大陆文件[usa.txt](ftp://ftp.cs.princeton.edu/pub/cs226/map/usa.txt)包含87,575个交叉口和121,961条道路。 图形非常稀疏 - 平均的度为2.8。 你的主要目标应该是快速回答这个网络上的顶点对的最短路径查询。 你的算法可能会有不同执行时间，这取决于两个顶点是否在附近或相距较远。 我们提供测试这两种情况的输入文件。 你可以假设所有的**x**和**y**坐标都是0到10,000之间的整数。

注：这个问题的实验由Bob Sedgewick和Kevin Wayne设计开发（Copyright © 2004）。更多信息可参考[http://algs4.cs.princeton.edu/](http://algs4.cs.princeton.edu/home/)。

## 二、算法实验报告+源代码
[实验报告+代码开源地址（GitHub）](https://github.com/Travis1024/Course_Code/tree/main/Algorithm_Experiment)
