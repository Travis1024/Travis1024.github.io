---
title: Meta-Transfer Learning for Few-Shot Learning （元迁移学习）
author: Travis <Hongxu Wei>
date: 2021-07-26 18:32:00 +0800
categories: [Paper Summary]
tags: [AI, Transfer Learning]
math: true
---



# Meta-Transfer Learning for Few-Shot Learning

## 一、先验知识

### 1.迁移学习

#### 1）迁移学习概念

随着越来越多的机器学习应用场景的出现，而现有表现比较好的监督学习需要大量的标注数据，标注数据是一项枯燥无味且花费巨大的任务，所以迁移学习受到越来越多的关注。然而实际使用过程中不同数据集可能存在一些问题，比如数据分布差异、标注数据过期等等，如何充分利用之前标注好的数据（废物利用），同时又保证在新的任务上的模型精度，这就是迁移学习所要解决的问题。

迁移学习的目标是将某个领域或任务上学习到的知识或模式应用到不同但相关的领域或问题中，从相关领域中迁移标注数据或者知识结构、完成或改进目标领域或任务的学习效果。

#### 2）领域自适应

领域自适应是迁移学习中的一种代表性方法，他的定义是将不同领域（比如两个不同的数据集）的数据特征映射到同一个特征空间，这样可利用其它领域数据来增强目标领域训练。

举个商品评论情感分析的例子来说，两个不同的产品领域：books 图书领域和 furniture 家具领域；在图书领域，通常用“纸张较好”、“字体清晰”等词汇来表达正面情感，而在家具领域中却由“稳固”、“重量适中”等词汇来表达正面情感。可见此任务中，不同领域的不同情感词多数不发生重叠、存在领域独享词、且词汇在不同领域出现的频率显著不同，因此会导致领域间的概率分布失配问题。

有时在一个感兴趣的领域中有一个分类任务，但是在另一个感兴趣的领域中只有足够的训练数据，在这种情况下，如果成功地进行知识迁移，就可以避免昂贵的数据标记工作，从而大大提高学习性能。

再次举例来说明，假设训练数据集是各种英短蓝猫，而想训练得到可以区分田园猫的模型，该模型相比于英短蓝猫识别情况性能会下降。当训练数据集和测试数据集分布不一致的情况下，通过在训练数据集上按经验误差最小准则训练得到的模型在测试数据集上性能不佳，因此引入了域适应技术。

源域（source domain）和目标域（target domain）共享相同的特征和类别，但是特征分布不同，如何利用信息丰富的源域样本来提升目标域模型的性能。**源域**表示与测试样本不同的领域，具有丰富的监督标注信息；**目标域**表示测试样本所在的领域，无标签或者只有少量标签。**源域和目标域往往属于同一类任务，但是分布不同。**

#### 3）UDA（无监督领域自适应）

无监督领域自适应的任务是利用源域中已有的知识或者说标签信息去学习目标域的样本的类别；源域Ds和目标域Dt的数据经验分布不一样，在UDA任务中，同样需要寻找一种源域和目标域之间的共有特征。
<img ssrc="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210716151830.png" style="zoom: 50%;" />

假设现在有一个特征抽取器
$$
f:\mathcal{X}\mapsto \mathcal{Z}
$$
可以抽取出“共有特征”，则根据这个f，可以构建出两个新的数据集，
$$
\mathcal{D}_s=\{(z^s_i=f(x^s_i),y^s_i)\}_{i=1}^{m}\\
\mathcal{D}_t=\{z^t_j=(x^t_j)\}_{j=1}^{n}
$$
采用这个特征抽取器的原因就是要找到一种共有特征
$$
\mathcal(z^s_i)
\mathcal(z^t_j)
$$
这些共有特征符合共同的经验分布，下面这是一个特征分类器：

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210716151849.png" style="zoom:67%;" />

#### 4）基于MMD的邻域自适应方法

此方法的整体流程图如下：

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210716151907.png" style="zoom:67%;" />

模型的基本结构很简单，包括一个特征抽取器和一个特征分类器
$$
G_f:\mathcal{X}\mapsto \mathcal{Z}\\
G_y:\mathcal{Z}\mapsto\mathcal{Y}
$$
输入源域数据xs，经过Gf变成特征zs，然后经过Gy变成分类概率ys，源域有真实的标签ys，所有可以构建一个分类loss函数，其中L是交叉熵损失。这个与传统的分类任务没有任何区别。
$$
L_y=\frac{1}{m}\sum_{i=1}^{m}L(f(x_i^s),y_i^s)
$$
在这方法中比较重要的一部分就是特征提取器部分，即对于邻域不变特征的提取，经过特征抽取器Gf，需要把所有的源域样本和目标域样本映射到特征空间，
$$
Z^s=\{z^s_1,z^s_2,\cdots,z^s_m\}\sim P\\
Z^t=\{z^t_1,z^t_2,\cdots,z^t_n\}\sim Q
$$
目标是寻找一种领域不变特征，即让分布P和Q之间的“距离”越来越少，让两个分布一样，即可说明找到了源域和目标域一个共同的表示空间。过程就如下图所示。

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210716152917.png" style="zoom: 50%;" />

可以用MMD来衡量P和Q之间的距离，并希望在训练过程中，GfGf能学习这样一组特征，使得MMD越来越小，所以可以构造这样一个loss函数,联合以上两个loss，可以联合训练一个简单的领域自适应模型。
$$
L_A = MMD(Z^s,Z^t)\\
L=\frac{1}{m}\sum_{i=1}^{m}L(f(x_i^s),y_i^s) + \lambda MMD(Z^s,Z^t)
$$
整个方法主要分为两个部分：即特征提取和特征分类部分。

### 2.元学习

#### 1）元学习概念

元学习（Meta Learning）或者叫做“学会学习”（Learning to learn），它是要“学会如何学习”，即利用以往的知识经验来指导新任务的学习，具有学会学习的能力。元学习的意图在于通过少量的训练实例设计能够快速学习新技能或适应新环境的模型。

当前的深度学习大部分情况下只能从头开始训练。使用参数微调来学习新任务，效果往往不好，而元学习就是研究如何让神经玩两个很好的利用以往的知识，使得能根据新任务的调整自己。

传统的机器学习研究模式是：获取特定任务的大型数据集，然后用这个数据集从头开始训练模型。很明显，这和人类利用以往经验，仅仅通过少量样本就迅速完成学习的情况相差甚远。（人类可以从少量样本中快速学习获取很大的认知能力，但算法模型则需要在大规模的数据集上得到训练才有可能达到人的识别能力）

一个良好的元学习模型能够很好地推广到在训练期间从未遇到过的新任务和新环境。最终，改编的模型可以完成新任务。这就是元学习也被称为学习如何学习的原因。

#### 2）元学习方法分类

1、基于记忆Memory的方法。
基本思路：因为要通过以往的经验来学习，那就可以通过在神经网络中添加Memory来实验。

2、基于预测梯度的方法。
基本思路：Meta Learning的目的是实现快速学习，而实现快速学习的关键点是神经网络的梯度下降要准和快，那么就可以让神经网络利用以往的任务学习如何预测梯度，这样面对新的任务，只要梯度预测的准，那么学习就会快。

3、利用Attention注意力机制
基本思路：训练一个Attention模型，在面对新任务时，能够直接的关注最重要部分。

4、借鉴LSTM的方法
基本思路：LSTM内部的更新非常类似于梯度下降的更新，那么能否利用LSTM的结构训练处一个神经网络的更新机制，输入当前网络参数，直接输出新的更新参数

5、面向RL的Meta Learning方法
基本思路：既然Meta Learning可以用在监督学习，那么增强学习上又可以怎么做呢？能否通过增加一些外部信息的输入比如reward，和之前的action来实验。

6、通过训练一个base model的方法，能同时应用到监督学习和增强学习上
基本思路：之前的方法只能局限在监督学习或增强学习上，能否做出一个更通用的模型。

7、利用WaveNet的方法
基本思路：WaveNet的网络每次都利用了之前的数据，那么能否照搬WaveNet的方式来实现Meta Learning呢？就是充分利用以往的数据。

8、预测Loss的方法
基本思路：要让学习的速度更快，除了更好的梯度，如果有更好的Loss，那么学习的速度也会更快，因此，可以构建一个模型利用以往的任务来学习如何预测Loss

#### 3）自注意力机制

自注意力机制实际上被广泛应用在自然语言处理中，是注意力机制的一种特殊情况，如果想要了解自注意力机制的推导过程和公式，可以研读一下《Attention is all you need》这篇论文，以便能够更加深入的了解自注意力机制和公式的含义，注意力机制（Attention）简单来说就是给定一个查找（query）和一个键值表（key-value pairs)，将查找映射到正确的输入的过程，由于查找、键、值和最后的结果都是向量的形式，所以输出常为加权求和的形式。



## 二、问题背景

传统上我们需要很多的训练数据才能训练出一个好的模型。但是在很多任务上，如：自动驾驶，无人机等，我们就需要快速地应对一些未见过的情形。

迁移学习通过在其他数据集上的大量训练，然后将其训练出的模型复制到目标任务上，最后在目标任务上通过少量标注数据对模型进行微调。但是这个基于梯度下降的方法在新任务上依然需要很多的标注数据。

元学习则是指一类只关注学习本身的学习算法。元学习在任务空间进行训练，而不是在（像迁移学习一样）实例空间进行训练。迁移学习在单个任务上进行优化，但是元学习会在任务空间里采样多个任务，然后在多个任务上学习。因此元学习模型理所应当的在未知任务上表现地更好。虽然元学习确实在few-shot learning上表现良好，但是当目标任务上可训练的样本较多时，元学习的性能就不太好了。比如可能随着时间的推移，我们积累了越来越多的标注数据，我们当然想要不断地提高我们的性能啦！但是随着数据的增多，元学习可能就不work了。还有一种情形是，目标任务的类别太多时，元学习的表现也不太好。

由此论文就想到了要结合元学习和迁移学习之优势，以弥补各自的不足。

## 三、论文工作

### 1.论文主要工作

1）提出了一种新的元迁移方法，该方法学习转移大规模预先训练的DNN权重来解决少样本学习任务；

2）提出了一种新颖的HT元批量学习策略，强制元迁移“在艰难中成长得更快更强”；

3）对两个少样本学习基准进行实验，并得出实验结果。

### 2.元学习阶段介绍

元学习主要包括两个阶段：元训练阶段（Meta-training）和元测试阶段（Meta-testing）

#### 1）元训练阶段（Meta-training）

元训练阶段主要目标是学习到一个最优的*w*。为了实现这一目的，元学习假定我们可以获取一些任务，它们采样自任务分布p(T)，组成Source Dataset。Source Dataset由M个数据集组成，每个数据集对应于一个任务。

#### 2）元测试阶段（Meta-testing）

元测试阶段主要目的是为了验证元知识的效果。类似地，在这个阶段，也从任务分布中采样Q个任务，构成Target Dataset。于是，在meta-testing阶段，我们可以基于Meta-training阶段求出的w*，为Target Dataset中的每个任务，在其训练集上进行训练，然后，用这些模型在相应的测试集上的测试结果来评估meta-leaner的总体性能。

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717010816.png" style="zoom: 67%;" />

### 3.少样本学习技术流程

少样本学习方法的技术路线如下图所示：

![](https://img-blog.csdnimg.cn/img_convert/9183f36e4cf7a510e7569a34eb7a4073.png)

该流程中主要可以划分为三个阶段：

①大规模数据的DNN训练，即使用所有训练数据点，同时将低层固定为特征提取器；

②元迁移学习基于预训练的特征提取器学习缩放和移动参数，为了提高总的学习效果，作者使用了Hard-task meta-batch策略；

③执行测试阶段；

### 4.少样本学习三阶段

#### 1）大规模数据DNN训练

这个阶段类似于经典的预训练阶段，在这一阶段中，我们不考虑来自其他数据集的数据/领域适应，并且在少样本学习基准中容易获得的数据上进行预训练，允许与其他少样本学习方法进行公平的比较。具体来说，对于一个特定的少样本数据集，我们合并所有类别的数据进行预处理。

首先初始化一个特征提取器（比如ResNets中的卷积层）和一个特征分类器（比如ResNets最后的全连接层），然后通过梯度下降对其进行优化，公式及损失函数如下所示：

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717012325.png" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717012337.png" style="zoom: 67%;" />

这个阶段将学习出特征抽取器Θ。它将在下面的元训练和元测试阶段被固定住，而学习出的分类器θ将被丢弃，因为接下来的任务中将包含不同的分类目标，比如5-class分类而不是训练时的64-class分类。
#### 2）元迁移学习

- MTL模型

  ​		通过Hard-Task meta-batch训练来优化”缩放和移动“操作（缩放和移动操作，即Scaling and Shifting (SS)可以简洁的表示为α X + β）。下图展示了通过SS和Fine-Tunning操作进行更新的区别。

  <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717152215.png" style="zoom: 80%;" />

- SS操作

  给定一个任务，其损失函数用于通过梯度下降来优化当前基础分类器，当前base-learner的参数θ‘的更新方法为公式如下所示：

  <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717012807.png" style="zoom:78%;" />
  

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717012936.png" style="zoom:75%;" />

其中公式中的θ以与等式中相同的学习速率γ进行更新：

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717013049.png" style="zoom:75%;" />

接下来，Φ应用于固定的神经元，给定训练后的Θ，它的第l层包含K个神经元，我们有K对参数，分别为权重和偏置，假定X为输入，公式为：

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717152655.png" style="zoom:60%;" />

------

- 阶段一、二算法过程如下图所示：大规模深层神经网络的训练（第1-5行）、元-迁移学习（第6-22行）、Hard Task meta-batch的重采样和连续训练阶段（第16-20行）

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717152800.png" style="zoom:80%;" />

------

#### 3）Hard task meta-batch

传统情况下的meta-batch由随机采样的任务组成。作者将模型预测错误的样本收集在一起重新组成一个更难的任务，然后重新训练。这就是hard task meta-batch。

SS操作的参数通过T的损失进行优化。我们可以得到模型在T上分别对M个类别的准确率，然后根据准确率大小进行排序。作者将学习设置成动态的在线学习，所以我们将从准确率较低的类别中重新对任务进行采样和训练。

------

- 单个任务上的学习过程：

  <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717153328.png" style="zoom:80%;" />

------

## 四、实验

### 1.实验数据集

论文在两个数据集上进行试验：miniImageNet 和 Fewshot-CIFAR100数据集。

- **miniImageNet**有100个类别，每个类别有600个样本，这100个类别被划分为：64,16,20类，分别用于meta-trianing, meta-validation和meta-test阶段。
- **Fewshot-CFAR100**包括100个类别，每个类别有600个样本，每个样本的尺寸是32 × 32。这100个类别属于20个超类。超类的划分为12 : 4 : 4 ，分别用于训练，验证和测试。

### 2.实验结果

- #### miniImageNet

  <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717153732.png" style="zoom:80%;" />

上表展示了各个方法在miniImageNet数据集上的实验结果。可以看到MTL+SS+Hard task meta-batch方法取得了最好的实验结果。

- **Fewshot-CFAR100**

  <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image@main//20210717153828.png" style="zoom:80%;" />


## 五、论文总结

本文提出了MTL模型，并使用Hard task meta-batch的课程学习策略进行训练。MTL模型独立于任何特定的网络，它可以被很好的进行拓展，而且Hard task meta-batch策略可以很容易地在在线迭代中使用。实验证明，MTL在预先训练的DNN神经元上的关键操作对于学习经验应用在看不见的任务上非常有效。在miniImageNet和Fewshot-CFAR100这两个实验中，论文提出的方法具有良好的性能。这种设计独立于任何特定的模型，只要任务的难度易于在线迭代评估时，方法的适应性就表现地较为良好。
