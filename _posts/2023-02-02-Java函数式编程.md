---
title: Java函数式编程
author: Travis <Hongxu Wei>
date: 2023-02-02 14:25:00 +0800
categories: [Java Learning Space]
tags: [Java]
math: false
---



[TOC]

## 1、函数式编程思想

函数式编程思想类似于我们数学中的函数，它主要关注的是对数据进行了什么操作。

优点：

-   代码简洁，开发快速

-   接近自然语言，易于理解

-   易于“并发编程”

    

## 2、Lambda表达式

Lambda是JDK8中一个语法糖，它可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现，让我们不用关注是什么对象，而是关注我们对数据进行了什么操作。

基本格式：
`(参数列表) -> {代码}`

**例1：**
我们在创建线程并启动时可以使用匿名内部类的写法

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("线程中run方法被执行");
    }
}).start();
```

Lambda表达式只关注有什么参数

```java
new Thread(() -> {
        System.out.println("线程中run方法被执行");
}).start();
```

**例2：**

```java
public static void main(String[] args) {
    int sum = calculateNum(new IntBinaryOperator() {
        @Override
        public int applyAsInt(int left, int right) {
            return left + right;
        }
    });
    System.out.println(sum);
}

// IntBinaryOperator为一个接口
public static int calculateNum(IntBinaryOperator operator) {
    int a = 10;
    int b = 20;
    return operator.applyAsInt(a, b);
}
```

匿名内部类 优化成Lambda表达式

```java
public static void main(String[] args) {
    int sum = calculateNum((int left, int right) -> {
        return left + right;
    });
    System.out.println(sum);
}
//IntBinaryOperator为一个接口
public static int calculateNum(IntBinaryOperator operator) {
    int a = 10;
    int b = 20;
    return operator.applyAsInt(a, b);
}
```

**例3：**

```java
public static void main(String[] args) {
    printNum(new IntPredicate() {
        @Override
        public boolean test(int value) {
            return value%2 == 0;
        }
    });
}

public static void printNum(IntPredicate predicate) {
    int[] arr = {1,2,3,4,5,6,7,8,9,10};
    for (int i : arr) {
        if (predicate.test(i)) {
            System.out.println(i);
        }
    }
}
```

优化

```java
public static void main(String[] args) {
    printNum((int value) -> {
        return value%2 == 0;
    });
}

public static void printNum(IntPredicate predicate) {
    int[] arr = {1,2,3,4,5,6,7,8,9,10};
    for (int i : arr) {
        if (predicate.test(i)) {
            System.out.println(i);
        }
    }
}
```

**例4：**

```java
public static void main(String[] args) {
    String str = typeConver(new Function<String, String>() {
        public String apply(String s) {
            return s + " hxp";
        }
    });
    System.out.println(str);
}

public static <R> R typeConver(Function<String,R> function) {
    String str = "hello";
    R result = function.apply(str);
    return result;
}
```

优化

```java
public static void main(String[] args) {
    String str = typeConver((String s) -> {
        return s + " hxp";
    });
    System.out.println(str);
}

public static <R> R typeConver(Function<String,R> function) {
    String str = "hello";
    R result = function.apply(str);
    return result;
}
```

再省略

```java
public static void main(String[] args) {
    String str = typeConver(s -> s + " hxp");
    System.out.println(str);
}
```

**总结：使用Lambda表达式替换匿名内部类，只需要保留匿名内部类的方法参数和方法体，然后在中间加一个箭头即可。**

**省略规则：**

-   参数类型可以省略
-   方法体只有一句代码时大括号return和唯一一句代码的分号可以省略
-   方法只有一个参数时，小括号可以省略
-   以上规则都可以省略不记，使用idea的快捷键 alt+enter



## 3、Stream流

Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作，可以更方便的让我们对集合或数组操作。

### (1) 入门案例

**案例准备：**

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode  // 去重
public class Author {
    private Long id;
    private String name;
    private Integer age;
    private String intro;
    private List<Book> books;
}
```

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class Book {
    private Long id;
    private String name;
    private String category;
    private Integer score;
    private String intro;
}
```

```java
public class StreamDemo {

    private static List<Author> getAuthors() {
        Author author = new Author(1L, "蒙多", 17, "一个祖安人", null);
        Author author2 = new Author(2L, "亚拉索", 18, "艾欧尼亚", null);
        Author author3 = new Author(3L, "易大师", 19, "黑色玫瑰", null);
        Author author4 = new Author(3L, "易大师", 19, "黑色玫瑰", null);

        List<Book> book1 = new ArrayList<>();
        List<Book> book2 = new ArrayList<>();
        List<Book> book3 = new ArrayList<>();
        List<Book> book4 = new ArrayList<>();

        book1.add(new Book(1L,"*","哲学,爱情", 80, "*"));
        book1.add(new Book(2L,"**","爱情,个人成长", 80, "**"));

        book2.add(new Book(3L,"***","爱情,传记", 70, "***"));
        book2.add(new Book(3L,"****","个人成长,传记", 70, "****"));
        book2.add(new Book(4L,"*****","哲学", 70, "*****"));

        book3.add(new Book(5L,"******","个人成长", 60, "******"));
        book3.add(new Book(6L,"*******","传记", 60, "*******"));
        book3.add(new Book(6L,"********","爱情", 60, "********"));

        book4.add(new Book(5L,"******","个人成长", 60, "******"));
        book4.add(new Book(6L,"*******","个人成长,传记,爱情", 60, "*******"));
        book4.add(new Book(6L,"********","哲学,爱情,个人成长", 60, "********"));


        author.setBooks(book1);
        author2.setBooks(book2);
        author3.setBooks(book3);
        author4.setBooks(book4);

        List<Author> authors = new ArrayList<>(Arrays.asList(author,author2,author3,author4));
        return authors;
    }
}
```

**案例：获取到作家的集合，打印出年龄小于18的作家的名字**

```java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()    //将集合转换成流
            .distinct() //去重
            .filter(new Predicate<Author>() {
                @Override
                public boolean test(Author author) {
                    return author.getAge() < 18;    //获取年龄小于18的对象
                }
            })
            .forEach(new Consumer<Author>() {
                @Override
                public void accept(Author author) {
                    System.out.println(author.getName());   //打印对象的名字
                }
            });
}
```

<img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image/202302022128703.png" style="zoom:50%"/>



### (2) 常用操作

#### <1> 创建流

-   **单例集合**：`集合对象.stream()`

    ```java
    List<Integer> list = new ArrayList<>();
    Stream<Integer> stream = list.stream();
    ```

-   **数组**：`Arrays.stream(数组)` 或 `Stream.of(数组)` 来创建

    ```java
    Integer[] arr = {1,2,3,4};
    Stream<Integer> stream1 = Arrays.stream(arr);
    Stream<Integer> stream2 = Stream.of(arr);
    ```

-   **双例集合**：转换成单例集合后再创建

    ```java
    Map<String, String> map = new HashMap<>();
    Stream<Map.Entry<String, String>> stream3 = map.entrySet().stream();
    ```

#### <2> 中间操作

-   **filter**

    对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。

    ```java
    public static void test() {
        List<Author> authors = getAuthors();
        authors.stream()
                .filter(author -> author.getAge() > 18) //中间操作
                .forEach(author -> System.out.println(author)); //终结操作
    }
    ```

-   **map**

    可以把流中的元素进行计算或转换。

    -   **转换**

        ```java
        public static void test() {
            List<Author> authors = getAuthors();
            authors.stream()
                    .map(new Function<Author, String>() {
                        //泛型中，第一个参数为方法的参数类型（流中的类型），第二个参数为方法的返回值类型
                        @Override
                        public String apply(Author author) {
                            return author.getName();
                        }
                    })
                    .forEach(new Consumer<String>() {
                        @Override
                        public void accept(String name) {
                            System.out.println(name);
                        }
                    });
        }
        ```

        简化：

        ```java
        public static void test() {
            List<Author> authors = getAuthors();
            //泛型中，第一个参数为方法的参数类型，第二个参数为方法的返回值类型
            authors.stream()
                    .map(author -> author.getName())
                    .forEach(name -> System.out.println(name));
        }
        ```

        <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image/202302022139414.png" style="zoom:50%"/>

    -   **计算**

        ```java
        public static void test() {
            List<Author> authors = getAuthors();
            //泛型中，第一个参数为方法的参数类型，第二个参数为方法的返回值类型
            authors.stream()
                    .map(author -> author.getAge())
                    .map(age -> age+10)
                    .forEach(age -> System.out.println(age));
        }
        ```

        <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image/202302022140740.png" style="zoom:50%"/>

-   **distinct**

    去除流中的重复元素。

    **注意：distinct方法是依赖Object的equals方法来判断是否是相同对象，所以需要重写equals方法。**

-   **sorted**

    对流中的元素进行排序。

    -   **方式一：调用sorted()空参方法**

        在比较的实体类上要实现Comparable接口，不然会报类型不匹配的异常。

        <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image/202302022142701.png" style="zoom:48%"/>

        ```java
        public static void test2() {
            List<Author> authors = getAuthors();
            authors.stream()
                    .distinct()
                    .sorted()
                    .forEach(author -> System.out.println(author.getAge()));
        }
        ```

    -   **方式二：在sorted方法中实现Comparator接口**

        ```java
        public static void test2() {
            List<Author> authors = getAuthors();
            authors.stream()
                    .distinct()
                    .sorted(new Comparator<Author>() {
                        @Override
                        public int compare(Author o1, Author o2) {
                            return o1.getAge()-o2.getAge();
                        }
                    })
                    .forEach(author -> System.out.println(author.getAge()));
        }
        ```

        优化：

        ```java
        public static void test2() {
            List<Author> authors = getAuthors();
            authors.stream()
                    .distinct()
                    .sorted((o1, o2) -> o1.getAge()-o2.getAge())
                    .forEach(author -> System.out.println(author.getAge()));
        }
        ```

-   **limit**

    可以设置流的最大长度，超出的部分将被抛弃。

    ```java
    //对流中的元素按照年龄进行降序排序，并且要求不能有重复元素，打印其中年龄最大的两个作家。
    public static void test2() {
        List<Author> authors = getAuthors();
        authors.stream()
                .distinct()
                .sorted((o1, o2) -> o2.getAge()-o1.getAge())
                .limit(2)
                .forEach(author -> System.out.println(author.getName()));
    }
    ```

-   **skip**

    跳过流中的前n个元素，返回剩下的元素。

-   **flatMap**

    map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。

-   **案例1：打印所有书籍的名字，要求对重复的元素进行去重。**

    map方式：Author对象的books属性是集合类型，使用原来map转换对象，要使用嵌套循环进行打印。

    ```java
    public static void test2() {
        List<Author> authors = getAuthors();
        authors.stream()
                .map(author -> author.getBooks())
                .forEach(books -> {
                    for (Book book : books) {
                        System.out.println(book.getName());
                    }
                });
    }
    ```

    flatMap方式：

    ```java
    public static void test2() {
        List<Author> authors = getAuthors();
        authors.stream()
                .flatMap(author -> author.getBooks().stream())
                .forEach(book -> System.out.println(book.getName()));
    }
    ```

    

-   **案例2：打印现有数据的所有分类，要求对分类进行去重。不能出现这种格式：哲学,爱情，要将它们拆开输出。**

    ```java
    public static void test3() {
        List<Author> authors = getAuthors();
        authors.stream()
                .flatMap(author -> author.getBooks().stream())
                .distinct()
                .flatMap(book -> Arrays.stream(book.getCategory().split(",")))
                .distinct()
                .forEach(category -> System.out.println(category));
    }
    ```

    <img src="https://cdn.jsdelivr.net/gh/Travis1024/PicGo_image/202302022146179.png" style="zoom:50%"/>

#### <3> 终结操作

-   **forEach**

    对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。

-   **count**

    获取当前流中元素的个数。

    ```java
    //打印这些作家的所出书籍的数量
    public static void test4() {
        List<Author> authors = getAuthors();
        long count = authors.stream()
                .flatMap(author -> author.getBooks().stream())
                .distinct()
                .count();
        System.out.println(count);
    }
    ```

-   **max&min**

    获取流中的最值

    ```java
    //分别获取这些作家所出书籍的最高分和最低分
    public static void test4() {
        List<Author> authors = getAuthors();
        Optional<Integer> max = authors.stream()
                .flatMap(author -> author.getBooks().stream())
                .map(book -> book.getScore())
                .max((o1, o2) -> o1 - o2);
        Optional<Integer> min = authors.stream()
                .flatMap(author -> author.getBooks().stream())
                .map(book -> book.getScore())
                .min(((o1, o2) -> o1 - o2));
        System.out.println(max.get());
        System.out.println(min.get());
    }
    ```

-   **collect**

    把当前流转换成一个集合。

    -   list集合

        ```java
        //获取一个存放所有作者名字的list集合
        public static void test5() {
            List<Author> authors = getAuthors();
            List<String> nameList = authors.stream()
                    .map(author -> author.getName())
                    .collect(Collectors.toList());
            System.out.println(nameList);
        }
        ```

    -   set集合

        ```java
        //获取一个存放所有作者名字的set集合
        public static void test5() {
            List<Author> authors = getAuthors();
            Set<String> nameList = authors.stream()
                    .map(author -> author.getName())
                    .collect(Collectors.toSet());
            System.out.println(nameList);
        }
        ```

    -   map集合

        ```java
        //获取一个Map集合，map的key为作者名，value为List<Book>
        public static void test5() {
            List<Author> authors = getAuthors();
            Map<String, List<Book>> map = authors.stream()
                    .distinct()
                    .collect(Collectors.toMap(author -> author.getName(), author -> author.getBooks()));
            System.out.println(map);
        }
        ```

        

-   **查找与匹配**

    -   **anyMatch**：判断是否有任意符合匹配条件的元素，结果为boolean类型。

        ```java
        //判断是否有作家年龄在18以上
        public static void test6() {
            List<Author> authors = getAuthors();
            boolean flag = authors.stream()
                    .anyMatch(author -> author.getAge() > 18);
            System.out.println(flag);
        }
        ```

    -   **allMatch**：判断是否都符合条件，如果都符合返回true，否则返回false。

        ```java
        //判断是否所有作家年龄在18以上
        public static void test6() {
            List<Author> authors = getAuthors();
            boolean flag = authors.stream()
                    .allMatch(author -> author.getAge() > 18);
            System.out.println(flag);
        }
        ```

    -   **noneMatch**：判断流中的元素是否都不符合匹配条件，如果都不符合结果为true，否则结果为false。

    -   **findAny**：获取流中的任意一个元素。该方法没有办法保证获取到的一定是流中的第一个元素。

        ```java
        //获取任意一个年龄大于18的作家，如果存在就输出他的名字
        public static void test7() {
            List<Author> authors = getAuthors();
            Optional<Author> any = authors.stream()
                    .filter(author -> author.getAge() > 18)
                    .findAny();
            //如果这个Optional中有元素，则执行方法，没有就不执行
            any.ifPresent(author -> System.out.println(author.getName()));
        }
        ```

    -   **findFirst**：获取流中的第一个元素。

        ```java
        //获取一个年龄最小的作家，并输出他的姓名
        public static void test7() {
            List<Author> authors = getAuthors();
            Optional<Author> any = authors.stream()
                    .sorted((o1, o2) -> o1.getAge()-o2.getAge())
                    .findFirst();
            any.ifPresent(author -> System.out.println(author.getName()));
        }
        ```

    -   **reduce归并**

        对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）

        reduce的作用是把stream中的元素给组合起来。我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。

        它内部的计算方式如下：

        ```java
        T result = identity;
        for (T element : this stream)
        	result = accumulator.apply(result, element)
        return result;
        ```

        其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。

    -   **案例1：使用reduce求所有作者年龄的和**

        ```java
        public static void test8() {
            List<Author> authors = getAuthors();
            Integer sum = authors.stream()
                    .distinct()
                    .map(author -> author.getAge())
                    //初始值为0，后面 result+=element，最后 return result
                    .reduce(0, (result, element) -> result + element);
            System.out.println(sum);
        }
        ```

    -   **案例2：使用reduce求所有作者中年龄的最大值**

        ```java
        public static void test8() {
            List<Author> authors = getAuthors();
            Integer max = authors.stream()
                    .map(author -> author.getAge())
                    .reduce(Integer.MIN_VALUE, (result, element) -> result > element ? result : element);
            System.out.println(max);
        }
        ```

        **reduce有个重载形式，内部代码如下：**

        ```java
        boolean foundAny = false;
        T result = null;
        for (T element : this stream) {
        	if(!foundAny) {
        		foundAny = true;
        		result = element;
        	} else {
        		result = accumulator.apply(result, element);
        	}
        }
        return foundAny ? Optional.of(result) : Optional.empty();
        ```

        利用这个重载形式，求作者年龄的最大值，不用传递初始值了。

        ```java
        public static void test8() {
            List<Author> authors = getAuthors();
            Optional<Integer> max = authors.stream()
                    .map(author -> author.getAge())
                    .reduce((result, element) -> result > element ? result : element);
            System.out.println(max.get());
        }
        ```

        **注意事项**

        **惰性求值**：如果没有终结操作，中间操作是不会得到执行的。

        **流是一次性的**：一旦一个流对象经过一个终结操作后，这个流就不能再被使用了，只能重新创建流对象再使用。

        **不会影响原数据**：我们在流中可以对数据做很多处理，但正常情况下是不会影响原来集合中的元素的。



## 4、Optional

### (1) 创建对象

### (2) 安全消费值

### (3) 安全获取值

### (4) 过滤

### (5) 判断

### (6) 数据转换



## 5、函数式接口

### (1) 常见函数式接口

### (2) 常用的默认方法



## 6、方法引用

### (1) 引用类的静态方法

### (2) 引用对象的实例方法

### (3) 引用类的实例方法

### (4) 构造器的引用



## 7、高级用法

### (1) 基本数据类型优化

### (2) 并行流



