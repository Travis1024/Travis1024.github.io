---
title: RabbitMQ与Kafka
author: Travis <Hongxu Wei>
date: 2023-03-12 22:10:55 +0800
categories: [Java Learning Space]
tags: [rabbitmq, kafka]
math: false
---

## 一、常见区别

#### 1、应用场景方面

RabbitMQ：用于实时的，对可靠性要求较高的消息传递上。
kafka：用于处于活跃的流式数据，大数据量的数据处理上。

#### 2、架构模型方面

producer，broker，consumer

RabbitMQ：以broker为中心，有消息的确认机制（这里的确认机制指的是客户端消费消息的时候）
kafka：以consumer为中心，无消息的确认机制（这里的确认机制指的是客户端消费消息的时候）

kafka和rabbitMQ都有发送到Broker的确认机制。

#### 3、吞吐量方面

RabbitMQ：支持消息的可靠的传递，支持事务，不支持批量操作，基于存储的可靠性的要求存储可以采用内存或硬盘，吞吐量小。如果需要持久化，会采用实时存储。

kafka：内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高，吞吐量高。定时持久化存储，非实时持久化储存

#### 4、集群负载均衡方面

RabbitMQ：本身不支持负载均衡，需要loadbalancer的支持。即指定存到哪个broker就是哪个broker。

kafka：采用zookeeper对集群中的broker，consumer进行管理，可以注册topic到zookeeper上，通过zookeeper的协调机制，producer保存对应的topic的broker信息，可以随机或者轮询发送到broker上，producer可以基于语义指定分片，消息发送到broker的某个分片上。即如果不指定分片，就会默认存到master的分片上，然后再同步到其他的分片。

## 二、少见区别

#### 1、消费者端拉取消息的方式不同

RabbitMQ：采用push的方式，当消息到达队列后，会将消息推到消费者端。
kafka：采用pull的方式，当消息到达队列后，消费者端需要手动从队列拉取消息。

#### 2、消息被处理完后的处理方式不同

RabbitMQ：被消费者端确认消费了的消息会被从磁盘删除掉。

kafka：消息被消费掉依然保存在磁盘中。

#### 3、生产者发送消息到broker的方式不同

RabbitMQ：当为**主从集群**的时候，生产者连接到谁，发送消息就到对应的机器上，其他机器只是存储元数据。消费者连接时，只需要连接任意集群中的**任意一台服务器**，获取数据时都可以通过元数据经过**路由**到达实际存储队列消息的那台服务器。

kafka：当生产者发送消息时，必须发送到master分片所在的机器。为了实现这一个功能，kafka在连接集群时，只要连接到**任意一台或多台**服务器，就可以**知道整个集群**的情况，其中包含了集群所有机器的ip地址，分片的信息。

## 三、基本未见区别，多涉及集群

#### 1、队列同步发起方（Rabbit使用的镜像集群，非默认的主从集群）

RabbitMQ：镜像队列同步时，由主队列向镜像队列发起。

kafka：副本同步时，副本分片由副本分片向主分片发起同步。

#### 2、副本同步限制

RabbitMQ：副本队列可以落后主队列很多。

kafka：副本分片只能落后**replica.lag.time.max.ms**的时间内（ISR），如果超过这个时间，副本分片会被删除掉。

#### 3、副本同步对性能的影响（Rabbit使用的镜像集群，非默认的主从集群）

RabbitMQ：新节点加入时，如果**ha-sync-mode=manual**，则不会手动同步镜像到新节点。如果**ha-sync-mode=automatic**时，会自动同步到新节点中。在同步新节点时，主节点不会再接收生产者的消息，也不会push消息到消费者，就是一种stop-the-world的状态。如果存量消息过多，则会导致生产者和消费者请求超时，可以使用设置重试规则解决。
kafka：新的节点加入，会主动从主分区拉取数据，等待数据拉取完成（不包含未提交的，只包含所有已提交数据）后才把该节点加入到集群中。



## 四、总结

- rabbit为了更高的灵活性和信息安全性，放弃了吞吐量

- kafka为了更多的吞吐量，选择了速度，放弃了部分安全性。