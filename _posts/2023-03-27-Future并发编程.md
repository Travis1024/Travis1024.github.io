---
title: Future并发编程
author: Travis <Hongxu Wei>
date: 2023-03-27 16:13:04 +0800
categories: [Java Learning Space]
tags: [future]
math: false
---

## 一、Future类

Future类：future类的是一种**异步任务监视器**，可以让提交者可以监视任务的执行，同时可以取消任务的执行，也可以获取任务返回结果。

比如在做一定的任务运算的时候，需要等待比较长时间，这个任务是比较耗时的，需要比较繁重的运算，比如加密、压缩等等。如果一直在等程序执行完成是不明智的，这时可以将这个比较耗时的任务交给子线程执行，然后通过Future类监控线程执行，获取返回的结果。这样一来就提高了工作效率，这是一种**异步**的思想。

## 二、Future接口

Future接口主要包含5个方法

<img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202303271559149.png" alt="image-20230327155909102" style="zoom:90%;" />

- cancel(boolean mayInterruptIfRunning)：取消任务的执行

  执行这个方法时候，会有三种情况，

  - 第一种情况，**任务还没开始执行**，调用了这个方法，这种情况比较好理解，这个任务会被正常取消，然后返回true

  - 第二种情况，也比较简单，假如任务**已经执行完成或者是已经执行过一次取消任务**的方法，这种情况如果再调用这个方法，是会取消失败的，返回false。因为任务无论是已完成还是已经被取消过了，都不能再被取消了

  - 第三种情况，是**任务正在执行**，这种情况就会根据我们传入的`mayInterruptIfRunning`参数进行分情况调用，如果这个值为true，执行任务的线程就会收到一个中断的信号，然后执行中断任务的逻辑，然后返回。如果这种值为false，任务就不会被取消，继续执行，同时会返回false，表示不执行取消任务操作

- isCancelled()：获取是否取消了任务

  这个方法用于判断任务是否被取消了，比较简单

- isDone()：任务是否执行完成

  这个方法如果返回true，则表示执行完成了，返回false，表示还没执行完成。这里有一种特殊情况需要特别注意，就是如果执行任务的过程发生了Exception，这种情况还是会被当成执行完成的，因为抛出Exception的任务，在”Future“也是不会执行的，所以都当成执行完成返回true

- get()：当任务结束后返回一个结果，如果调用时，工作还没有结束，则会阻塞线程，直到任务执行完毕
- get(long timeout, TimeUnit unit)：最多等待timeout的时间就会返回结果



## 三、RPC使用Future示例

- 创建RpcFuture实现Future<T>接口

  ```java
  package com.space.travis.client.transport;
  import java.util.concurrent.*;
  /**
   * @ClassName RpcFuture
   * @Description 异步执行结果获取
   * @Author travis-wei
   * @Version v1.0
   * @Data 2023/3/3
   */
  public class RpcFuture<T> implements Future<T> {
      /**
       * 响应结果
       */
      private T response;
      /**
       * 使用 CountDownLatch 等待线程，当获取到响应的时候setResponse函数被调用，countDownLatch减到0，阻塞的get开始执行。
       * 因为一个请求对应一个future对象，所以初始设置为1
       */
      private CountDownLatch countDownLatch = new CountDownLatch(1);
  
      @Override
      public boolean cancel(boolean mayInterruptIfRunning) {
          return false;
      }
  
      @Override
      public boolean isCancelled() {
          return false;
      }
  
      @Override
      public boolean isDone() {
          return false;
      }
  
      @Override
      public T get() throws InterruptedException, ExecutionException {
          // 进入阻塞状态，等待countDownLatch减少值为0 返回响应结果
          countDownLatch.await();
          return response;
      }
  
      @Override
      public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
          if (countDownLatch.await(timeout, unit)) {
              return response;
          }
          // 如果超时，则返回null
          return null;
      }
  
      /**
       * 当handler获取到响应时，调用此方法，设置响应结果，让countDownLatch减到0，使得被阻塞的get方法开始执行
       * @param response
       */
      public void setResponse(T response){
          this.response = response;
          countDownLatch.countDown();
      }
  }
  ```

  

- 在请求异步执行时，创建RpcFuture实例，返回结果时，返回rpcFuture.get()

  ```java
  @Override
  public MessageProtocol<RpcResponseBody> sendRequest(RequestMetaData requestMetaData) throws ExecutionException, InterruptedException, TimeoutException {
      MessageProtocol<RpcRequestBody> messageProtocol = requestMetaData.getMessageProtocol();
      // 创建异步执行结果类
      RpcFuture<MessageProtocol<RpcResponseBody>> rpcFuture = new RpcFuture<>();
      // 添加请求和响应的映射关系
      LocalRpcProcessCache.cacheAdd(messageProtocol.getMessageHeader().getRequestID(), rpcFuture);
  
      try {
          // bind and start to accept incoming connections
          ChannelFuture channelFuture = bootstrap.connect(requestMetaData.getAddress(), requestMetaData.getPort());
          channelFuture.sync();
          /**
           * 异步非阻塞式连接，调用channelFuture.addListener(),添加监听器，线程无需阻塞等待连接，可以继续向下执行代码逻辑 (这里只是监听连接是否成功，不是监听响应)
           * 当连接建立成功之后，其他线程会自动调用监听器中的operationComplete()方法, operationComplete()方法并非主线程调用，而是NioEventLoopGroup线程组中的一个NioEventLoop线程调用
           */
          channelFuture.addListener(new ChannelFutureListener() {
              @Override
              public void operationComplete(ChannelFuture channelFuture1) {
                  if (channelFuture1.isSuccess()) {
                      log.info("connect rpc server {} on port {} success.", requestMetaData.getAddress(), requestMetaData.getPort());
                  } else {
                      log.error("connect rpc server {} on port {} failed.", requestMetaData.getAddress(), requestMetaData.getPort());
                      log.error("执行出错：" + channelFuture1.cause().getMessage());
                  }
              }
          });
          // 建立连接成功之后，执行IO读写操作，写入数据
          // write和flush属于outbound事件，执行编码handler
          channelFuture.channel().writeAndFlush(messageProtocol);
      } catch (Exception e) {
          log.error(String.valueOf(e));
          e.printStackTrace();
      }
      // 可以在主程序中顺序执行到这里，不被阻塞
      // 但是在rpcFuture.get()获取响应结果时会被阻塞，需要等待响应结果，当接收到响应时，首先执行的是解码和handler
      if (requestMetaData.getTimeOut() != null) {
          // 如果超时，则返回null
          return rpcFuture.get(requestMetaData.getTimeOut(), TimeUnit.SECONDS);
      }
      return rpcFuture.get();
  }
  ```



- 当异步执行结束，获取到响应时，调用RpcFuture类的setResponse方法，让countDownLatch减到0，使得被阻塞的get方法开始执行。

  ```java
  /**
   * @ClassName NettyRpcClientHandler
   * @Description 消息响应处理
   * @Author travis-wei
   * @Version v1.0
   * @Data 2023/3/3
   */
  @Slf4j
  public class NettyRpcClientHandler extends SimpleChannelInboundHandler<MessageProtocol<RpcResponseBody>> {
  
      /**
       * 接收到服务端响应信息时执行的方法
       * @param channelHandlerContext
       * @param rpcResponseBodyMessageProtocol
       * @throws Exception
       */
      @Override
      protected void channelRead0(ChannelHandlerContext channelHandlerContext, MessageProtocol<RpcResponseBody> rpcResponseBodyMessageProtocol) throws Exception {
          log.info("========已收到响应，且响应消息解码成功 -> 正在匹配请求与响应信息========");
          /**
           * 根据消息请求ID获取缓存的future对象
           */
          RpcFuture<MessageProtocol<RpcResponseBody>> rpcFuture = LocalRpcProcessCache.getFutureByRequestID(rpcResponseBodyMessageProtocol.getMessageHeader().getRequestID());
          if (rpcFuture == null) {
              log.error("请求与响应匹配失败！");
              throw new Exception("错误：找不到对应消息请求ID的缓存，消息ID可能出现损坏！");
          }
          log.info("匹配成功！");
          // 删除此请求对应的映射缓存
          LocalRpcProcessCache.deleteCache(rpcResponseBodyMessageProtocol.getMessageHeader().getRequestID());
          /**
           * 向异步执行结果类中注入结果，并解除rpcFuture.get()的阻塞状态
           */
          rpcFuture.setResponse(rpcResponseBodyMessageProtocol);
      }
  }
  ```

  