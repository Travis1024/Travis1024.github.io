ℹ️	**主要作用：**

- 线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值
- 顺序一致性：禁止指令重排序



## 一、线程可见性

### 1、线程可见性示例

先通过一个例子来看看线程的可见性：

```java
public class VolatileTest {
    boolean flag = true;

    public void updateFlag() {
        this.flag = false;
        System.out.println("修改flag值为：" + this.flag);
    }

    public static void main(String[] args) {
        VolatileTest test = new VolatileTest();
        new Thread(() -> {
            while (test.flag) {
            }
            System.out.println(Thread.currentThread().getName() + "结束");
        }, "Thread1").start();

        new Thread(() -> {
            try {
                Thread.sleep(2000);
                test.updateFlag();
            } catch (InterruptedException e) {
            }
        }, "Thread2").start();

    }
}
```

打印结果如下：

```
修改flag值为：false
```

虽然线程Thread2已经把flag修改为false，但是线程Thread1没有读取到flag修改后的值，线程一直在运行。

**此时把flag变量加上volatile关键字**

```java
volatile boolean flag = true；
```

重新运行程序，打印结果为：

```
修改flag值为：false
Thread1结果
```

### 2、内存模型

<img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202303280919098.png" alt="image-20230328091938042" style="zoom:50%;" />

线程之间的共享变量存储在主内存中（Main Memory）中，每个线程都有一个私有的本地内存地址（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。

所以当一个线程把主内存中的共享变量读取到自己的本地内存中，然后进行了更新，在还没有把共享变量刷新到主内存的时候，另外一个线程是看不到的

- 如何把修改后的值刷新到主内存中？

  现代处理器使用写缓冲区临时保存向内存写入的数据，写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，较少对内存总线的占用，但是什么时候写入到内存是不知道的。

  <img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202303280933996.png" alt="image-20230328093307961" style="zoom:50%;" />

  所以由此引入了volatile

- volatile是如何保证可见性的？

  在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，会多出lock addl。Lock前缀的指令在多核处理器下会引发两件事情：

  - 将当前处理器缓存行的数据写回到系统内存。

  - 这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效。

    如果声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的还是旧的，在执行操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。



## 二、顺序一致性

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为如下三种：

源代码	➡️	1. 编译器优化重排序	➡️	2. 指令级并行重排序	➡️	3. 内存系统重排序	➡️	最终执行的指令序列

1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。

当变量声明为volatile时，Java编译器在生成指令序列时，会插入内存屏障指令。通过内存屏障指令来禁止重排序。

- JMM内存屏障插入策略如下：
  - 在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个StoreLoad屏障。
  - 在每个volatile读操作后面插入一个LoadLoad，LoadStore屏障。

- volatile写插入内存屏障后生成指令序列示意图：

  <img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202303280940798.png" alt="image-20230328094015760" style="zoom:40%;" />

- volatile读插入内存屏障后生成指令序列示意图：

  <img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202303280941930.png" alt="image-20230328094123906" style="zoom:40%;" />

通过上面这些我们可以得出如下结论：编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。

防止重排序使用案例：

```java
public class SafeDoubleCheckedLocking {
    private volatile static Instance instane;
    public  static Instance getInstane(){
        if(instane==null){
            synchronized (SafeDoubleCheckedLocking.class){
                if(instane==null){
                    instane=new Instance();
                }
            }
        }
        return instane;
    }
}
```



- 创建一个对象主要分为如下三步：
  - 分配对象的内存空间
  - 初始化对象
  - 设置instance指向内存空间

如果instane 不加volatile，上面的2，3可能会发生重排序。假设A，B两个线程同时获取，A线程获取到了锁，发生了指令重排序，先设置了instance指向内存空间。这个时候B线程也来获取，instance不为空，这样B拿到了没有初始化完成的单例对象（如下图）

<img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202303280943246.png" alt="image-20230328094357214" style="zoom:40%;" />

## 三、volatile和synchronized比较

1. Volatile是轻量级的synchronized，因为它不会引起上下文的切换和调度，所以Volatile性能更好。
2. Volatile只能修饰变量，synchronized可以修饰方法，静态方法，代码块。
3. Volatile对任意单个变量的读/写具有原子性，但是类似于i++这种复合操作不具有原子性。而锁的互斥执行的特性可以确保对整个临界区代码执行具有原子性。
4. 多线程访问volatile不会发生阻塞，而synchronized会发生阻塞。
5. volatile是变量在多线程之间的可见性，synchronize是多线程之间访问资源的同步性。



## 附录

[volatile关键字的作用](https://blog.csdn.net/xinghui_liu/article/details/124379221)
