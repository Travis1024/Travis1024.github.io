---
title: JVM内存分析
author: Travis <Hongxu Wei>
date: 2023-06-25 11:00:16 +0800
categories: [Java Learning Space]
tags: [jvm]
math: false
---



## 方法区、元数据区、永久代之间的关系

方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。

并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现便成为元空间。

永久代使用的是 JVM 虚拟机内存空间，元空间使用的是直接内存。

整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

<img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202306251101208.png" alt="image-20230625110118108" style="zoom:50%;" />

JDK 1.8：静态变量和字符串常量池放在 ”堆“ 中，运行时常量池放在 ”元数据区“ 中



## JVM 常量池中存储的是对象还是引用呢？

JDK1.8版本中，**字符串常量池**已经从**方法区**中的**运行时常量池**分离到堆中了，那么在堆中的**字符串常量池**里存的是String对象还是引用呢？直接查看API：

<img src="https://travisnotes.oss-cn-shanghai.aliyuncs.com/mdpic/202306251115216.webp" alt="img" style="zoom:50%;" />

翻译：String类的intern()方法：一个初始为空的字符串池，它由类String独自维护。当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象（注意是常量池中的对象，不是堆中的对象）的引用。 对于任意两个字符串s和t，当且仅当s.equals(t)为true时，s.intern() == t.intern()才为true。所有字面值字符串和字符串赋值常量表达式都使用 intern方法进行操作。

> 总结：JDK1.8版本的字符串常量池中存的是字符串对象，以及字符串常量值



**附上常考面试题：**

- 输出结果？创建了几个对象？

```text
String s1 = "abc";
String s2 = "abc";
System.out.println(s1==s2);
```

结果输出：

```text
true
```

创建了1个对象。采用**字面值的方式**创建一个字符串时，JVM首先会去字符串池中查找是否存在"abc"这个对象，如果不存在，则在字符串池中创建"abc"这个对象，然后将池中"abc"这个对象的引用地址返回给"abc"对象的引用s1，这样s1会指向池中"abc"这个字符串对象；如果存在，则不创建任何对象，直接将池中"abc"这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的"abc"对象，所以结果为true。



- 输出结果？创建了几个对象？

```text
String s3 = new String("xyz");
String s4 = new String("xyz");
System.out.println(s3==s4);
```

结果输出：

```text
false
```

创建了3个对象。采用**new关键字**新建一个字符串对象时，JVM首先在字符串池中查找有没有"xyz"这个字符串对象，如果有，则不在池中再去创建"xyz"这个对象了，直接在堆中创建一个"xyz"字符串对象，然后将堆中的这个"xyz"对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个"xyz"字符串对象；如果没有，则首先在字符串池中创建一个"xyz"字符串对象，然后再在堆中创建一个"xyz"字符串对象，然后将堆中这个"xyz"字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个"xyz"字符串对象。s4则指向了堆中创建的另一个"xyz"字符串对象。s3 、s4是两个指向不同对象的引用，结果当然是false。



- 代码详解

```text
String s1 = new StringBuilder().append("ja").append("va1").toString();
System.out.println(s1.intern() == s1);
```

输出结果：

```text
true
```

详解：StringBuilder().toString()这个方法虽然是`new`了一个`String`对象，但其实和"java1"是一样的，大家可以看下源码，这里的`s1.intern()`返回的是常量池中字符串的引用，所以`s1.intern() == s1`。